"""Output formatting for meld results."""

import json
from typing import Any

from meld import __version__
from meld.data_models import SessionMetadata


class OutputFormatter:
    """Formats meld output in various formats."""

    def __init__(self, verbose: bool = False) -> None:
        """Initialize formatter."""
        self._verbose = verbose

    def format_final_plan(
        self,
        plan: str,
        session: SessionMetadata,
        verbose_outputs: list[str] | None = None,
        decision_log: str = "",
        round_summaries: list[dict[str, Any]] | None = None,
    ) -> str:
        """Format the final plan output as markdown.

        Args:
            plan: The final converged plan content.
            session: Session metadata.
            verbose_outputs: Raw advisor outputs (included if verbose mode).
            decision_log: Decision log content from synthesis.
            round_summaries: Optional list of per-round change summaries.

        Returns:
            Formatted markdown document.
        """
        # Determine status text
        if session.converged:
            status_text = f"Converged after {session.rounds_completed} rounds"
        else:
            status_text = f"Max rounds reached ({session.rounds_completed}/{session.max_rounds})"

        lines = [
            "# Implementation Plan",
            "",
            plan,
            "",
            "---",
            "",
            "## Run Report",
            "",
            f"**Session:** {session.session_id}",
            f"**Status:** {status_text}",
            f"**Advisors:** {self._format_advisor_status(session.advisors_participated)}",
            "",
        ]

        # Add round summary table if available
        if round_summaries:
            lines.extend([
                "### Round Summary",
                "",
                "| Round | Changes | Key Updates |",
                "|-------|---------|-------------|",
            ])
            for summary in round_summaries:
                round_num = summary.get("round", 0)
                changes = summary.get("changes", 0)
                updates = summary.get("updates", "No changes")
                lines.append(f"| {round_num} | {changes} | {updates} |")
            lines.append("")

        # Add decision log if present
        if decision_log:
            lines.extend([
                "### Decision Log",
                "",
                decision_log,
                "",
            ])

        # Add verbose advisor outputs if enabled
        if self._verbose and verbose_outputs:
            lines.extend([
                "---",
                "",
                "## Raw Advisor Outputs",
                "",
            ])
            for output in verbose_outputs:
                lines.append(output)
                lines.append("")

        lines.extend([
            "---",
            f"Generated by Meld v{__version__}",
        ])

        return "\n".join(lines)

    def format_run_report(
        self,
        session: SessionMetadata,
        decision_log: str = "",
        round_summaries: list[dict[str, Any]] | None = None,
        advisor_errors: dict[str, str] | None = None,
    ) -> str:
        """Format a standalone run report.

        Args:
            session: Session metadata.
            decision_log: Decision log content from synthesis.
            round_summaries: Optional list of per-round change summaries.
            advisor_errors: Dict of advisor name to error message for failures.

        Returns:
            Formatted markdown run report.
        """
        # Determine status text
        if session.converged:
            status_text = f"Converged after {session.rounds_completed} rounds"
        else:
            status_text = f"Max rounds reached ({session.rounds_completed}/{session.max_rounds})"

        lines = [
            "# Meld Run Report",
            "",
            f"**Session ID:** {session.session_id}",
            f"**Task:** {session.task[:100]}{'...' if len(session.task) > 100 else ''}",
            f"**Status:** {status_text}",
            f"**Advisors:** {self._format_advisor_status(session.advisors_participated, advisor_errors)}",
            "",
        ]

        # Add timing info if available
        if session.started_at and session.completed_at:
            duration = (session.completed_at - session.started_at).total_seconds()
            lines.extend([
                f"**Started:** {session.started_at.isoformat()}Z",
                f"**Completed:** {session.completed_at.isoformat()}Z",
                f"**Duration:** {duration:.1f}s",
                "",
            ])

        # Add round summary table
        lines.extend([
            "## Round Summary",
            "",
            "| Round | Changes | Key Updates |",
            "|-------|---------|-------------|",
        ])
        if round_summaries:
            for summary in round_summaries:
                round_num = summary.get("round", 0)
                changes = summary.get("changes", 0)
                updates = summary.get("updates", "No changes")
                lines.append(f"| {round_num} | {changes} | {updates} |")
        else:
            # Default entries for each round
            for i in range(1, session.rounds_completed + 1):
                lines.append(f"| {i} | - | - |")
        lines.append("")

        # Add decision log if present
        if decision_log:
            lines.extend([
                "## Decision Log",
                "",
                decision_log,
                "",
            ])

        lines.extend([
            "---",
            f"Generated by Meld v{__version__}",
        ])

        return "\n".join(lines)

    def format_json_summary(
        self,
        session: SessionMetadata,
        advisor_details: dict[str, dict[str, Any]] | None = None,
        convergence_info: dict[str, Any] | None = None,
    ) -> str:
        """Format session metadata as JSON.

        Args:
            session: Session metadata.
            advisor_details: Optional detailed advisor info with participation and errors.
            convergence_info: Optional convergence details (open_items, diff_ratio).

        Returns:
            JSON string with full summary.
        """
        # Calculate duration if times are available
        duration_seconds: float | None = None
        if session.started_at and session.completed_at:
            duration_seconds = (session.completed_at - session.started_at).total_seconds()

        # Build advisors object
        advisors: dict[str, dict[str, Any]] = {}
        if advisor_details:
            advisors = advisor_details
        else:
            # Build from participated list
            for advisor in session.advisors_participated:
                advisors[advisor] = {
                    "participated": True,
                    "rounds": list(range(1, session.rounds_completed + 1)),
                }

        # Build convergence object
        convergence = {
            "converged": session.converged,
            "open_items": convergence_info.get("open_items", 0) if convergence_info else 0,
            "final_diff_ratio": convergence_info.get("diff_ratio", 0.0) if convergence_info else 0.0,
        }

        data = {
            "version": __version__,
            "session_id": session.session_id,
            "status": "converged" if session.converged else session.status,
            "rounds_completed": session.rounds_completed,
            "max_rounds": session.max_rounds,
            "duration_seconds": duration_seconds,
            "advisors": advisors,
            "convergence": convergence,
            "task": session.task,
            "started_at": session.started_at.isoformat() + "Z" if session.started_at else None,
            "completed_at": session.completed_at.isoformat() + "Z" if session.completed_at else None,
        }
        return json.dumps(data, indent=2)

    def format_quiet_output(self, plan: str) -> str:
        """Format minimal output for quiet mode."""
        return plan

    def _format_advisor_status(
        self,
        participants: list[str],
        errors: dict[str, str] | None = None,
    ) -> str:
        """Format advisor participation status with checkmarks.

        Args:
            participants: List of advisors that participated.
            errors: Optional dict of advisor name to error message.

        Returns:
            Formatted string like "Claude ✓, Gemini ✓, Codex ✗"
        """
        all_advisors = ["claude", "gemini", "openai"]
        parts = []
        for advisor in all_advisors:
            display_name = advisor.capitalize()
            if advisor in participants:
                parts.append(f"{display_name} ✓")
            elif errors and advisor in errors:
                parts.append(f"{display_name} ✗")
            else:
                parts.append(f"{display_name} ✗")
        return ", ".join(parts)
